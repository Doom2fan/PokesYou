// Generated by the GOLD Parser Builder

using System.IO;
using System.Reflection;

namespace PokesYou.Data.UDMF {
    class UDMFParser {
        private GOLD.Parser parser = new GOLD.Parser ();

        private enum SymbolIndex {
            @Eof = 0,                                  // (EOF)
            @Error = 1,                                // (Error)
            @Comment = 2,                              // Comment
            @Newline = 3,                              // NewLine
            @Whitespace = 4,                           // Whitespace
            @Timesdiv = 5,                             // '*/'
            @Divtimes = 6,                             // '/*'
            @Divdiv = 7,                               // '//'
            @Semi = 8,                                 // ';'
            @Lbrace = 9,                               // '{'
            @Rbrace = 10,                              // '}'
            @Eq = 11,                                  // '='
            @Eof2 = 12,                                // EOF
            @Float = 13,                               // float
            @Identifier = 14,                          // identifier
            @Integer = 15,                             // integer
            @Quoted_string = 16,                       // 'quoted_string'
            @Assignment_expr = 17,                     // <assignment_expr>
            @Block = 18,                               // <block>
            @Expr_list = 19,                           // <expr_list>
            @Global_expr = 20,                         // <global_expr>
            @Global_expr_list = 21,                    // <global_expr_list>
            @Translation_unit = 22,                    // <translation_unit>
            @Value = 23                                // <value>
        }

        private enum ProductionIndex {
            @Translation_unit_Eof = 0,                 // <translation_unit> ::= <global_expr_list> EOF
            @Global_expr_list = 1,                     // <global_expr_list> ::= <global_expr> <global_expr_list>
            @Global_expr = 2,                          // <global_expr> ::= <block>
            @Global_expr2 = 3,                         // <global_expr> ::= <assignment_expr>
            @Block_Identifier_Lbrace_Rbrace = 4,       // <block> ::= identifier '{' <expr_list> '}'
            @Expr_list = 5,                            // <expr_list> ::= <assignment_expr> <expr_list>
            @Expr_list2 = 6,                           // <expr_list> ::= 
            @Assignment_expr_Identifier_Eq_Semi = 7,   // <assignment_expr> ::= identifier '=' <value> ';'
            @Value_Integer = 8,                        // <value> ::= integer
            @Value_Float = 9,                          // <value> ::= float
            @Value_Quoted_string = 10,                 // <value> ::= 'quoted_string'
            @Value_Identifier = 11                     // <value> ::= identifier
        }

        public object program;     // You might derive a specific object

        public void Setup () {
            // This procedure can be called to load the parse tables. The class can
            // read tables using a BinaryReader.
            using (var stream = new MemoryStream (Properties.Resources.UDMFGrammar, false)) {
                using (var reader = new BinaryReader (stream))
                    parser.LoadTables (reader);
            }
        }

        public bool Parse (TextReader reader) {
            // This procedure starts the GOLD Parser Engine and handles each of the
            // messages it returns. Each time a reduction is made, you can create new
            // custom object and reassign the .CurrentReduction property. Otherwise, 
            // the system will use the Reduction object that was returned.
            //
            // The resulting tree will be a pure representation of the language 
            // and will be ready to implement.

            GOLD.ParseMessage response;
            bool done;                      // Controls when we leave the loop
            bool accepted = false;          // Was the parse successful?

            parser.Open (reader);
            parser.TrimReductions = false;  // Please read about this feature before enabling  

            done = false;
            while (!done) {
                response = parser.Parse ();

                switch (response) {
                    case GOLD.ParseMessage.LexicalError:
                        // Cannot recognize token
                        done = true;
                        break;

                    case GOLD.ParseMessage.SyntaxError:
                        // Expecting a different token
                        done = true;
                        break;

                    case GOLD.ParseMessage.Reduction:
                        // Create a customized object to store the reduction

                        parser.CurrentReduction = CreateNewObject (parser.CurrentReduction as GOLD.Reduction);
                        break;

                    case GOLD.ParseMessage.Accept:
                        // Accepted!
                        //program = parser.CurrentReduction   // The root node!                 
                        done = true;
                        accepted = true;
                        break;

                    case GOLD.ParseMessage.TokenRead:
                        // You don't have to do anything here.
                        break;

                    case GOLD.ParseMessage.InternalError:
                        // INTERNAL ERROR! Something is horribly wrong.
                        done = true;
                        break;

                    case GOLD.ParseMessage.NotLoadedError:
                        // This error occurs if the CGT was not loaded.                   
                        done = true;
                        break;

                    case GOLD.ParseMessage.GroupError:
                        // GROUP ERROR! Unexpected end of file
                        done = true;
                        break;
                }
            }

            return accepted;
        }

        private object CreateNewObject (GOLD.Reduction r) {
            object result = null;

            switch ((ProductionIndex) r.Parent.TableIndex ()) {
                case ProductionIndex.Translation_unit_Eof:
                    // <translation_unit> ::= <global_expr_list> EOF
                    break;

                case ProductionIndex.Global_expr_list:
                    // <global_expr_list> ::= <global_expr> <global_expr_list>
                    break;

                case ProductionIndex.Global_expr:
                    // <global_expr> ::= <block>
                    break;

                case ProductionIndex.Global_expr2:
                    // <global_expr> ::= <assignment_expr>
                    break;

                case ProductionIndex.Block_Identifier_Lbrace_Rbrace:
                    // <block> ::= identifier '{' <expr_list> '}'
                    break;

                case ProductionIndex.Expr_list:
                    // <expr_list> ::= <assignment_expr> <expr_list>
                    break;

                case ProductionIndex.Expr_list2:
                    // <expr_list> ::= 
                    break;

                case ProductionIndex.Assignment_expr_Identifier_Eq_Semi:
                    // <assignment_expr> ::= identifier '=' <value> ';'
                    break;

                case ProductionIndex.Value_Integer:
                    // <value> ::= integer
                    break;

                case ProductionIndex.Value_Float:
                    // <value> ::= float
                    break;

                case ProductionIndex.Value_Quoted_string:
                    // <value> ::= 'quoted_string'
                    break;

                case ProductionIndex.Value_Identifier:
                    // <value> ::= identifier
                    break;

            }

            return result;
        }

    }
}